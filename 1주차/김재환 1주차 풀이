import java.util.Arrays;

class Solution {

    public int[] solution(int[] num_list) {
        // 배열의 길이를 n에 저장
        // 매번 num_list.length를 호출하는 것보다 이렇게 변수로 빼면 조금 더 깔끔함
        int n = num_list.length;

        // 결과를 담을 새 배열을 만듬
        // 원본 배열은 그대로 두고, 뒤집힌 형태를 따로 저장할 겁니다.
        int[] answer = new int[n];

        // i번째 자리에 원본의 (n-1-i)번째 값을 삽입
        // 즉, 맨 뒤에서부터 하나씩 복사해오는 구조
        Arrays.setAll(answer, i -> num_list[n - 1 - i]);

        return answer;
    }
}

/* MY_Antidote
 이 방식은 솔직히 효율만 따지면 최악입니다.
 새 배열을 만들어서 뒤집기 때문에 메모리를 더 쓰거든요.
 그냥 for문 2개 써도 충분히 가능합니다.
 그래도 저는 남들이 쓰지 않는 방식을 하고 싶었어요.(인덱스로 함수를 매핑한다는 점/16줄)
  배열 문제는 결국 '인덱스를 어떻게 바라보는가'의 싸움이라 생각합니다.
  값보다 위치의 관계를 먼저 이해하면 코드가 훨씬 단순해져요.
  뒤집기 문제도 결국 "i와 (n-1-i)이 서로 마주본다"는 개념 하나로 정리됩니다.
 */

class Solution {
    public int[] solution(long n) {

        // n이 몇 자리인지 모르므로 문자열로 바꿔 길이를 구합니다.
        // (수학적으로 자리수 계산해도 되지만, 문자열 변환이 훨씬 직관적이에요.)
        String str = String.valueOf(n);
        int len = str.length();

        // 자리수만큼 크기의 int 배열을 만듭니다.
        int[] answer = new int[len];

        // 맨 뒤(1의 자리)부터 앞으로 한 자리씩 꺼내서 배열에 채웁니다.
        for (int i = 0; i < len; i++) {
            // n % 10 → 마지막 자리 숫자
            // n /= 10 → 마지막 자리 제거
            answer[i] = (int)(n % 10);
            n /= 10;
        }

        // 이미 뒤집힌 상태로 채워졌기 때문에 별도의 reverse 과정이 필요 없습니다.
        return answer;
    }
}

/*
 * 이 풀이는 단순하지만 가장 명확합니다.
 * 숫자를 직접 나누면서 1의 자리부터 저장하기 때문에
 * 뒤집힌 결과가 자연스럽게 만들어집니다.
 * 
 * 문제를 단순하게 바라볼수록 코드도 간결해진다고 느꼈어요.
 * "뒤집는다"를 복잡하게 생각하기보다,
 * "뒤에서부터 하나씩 꺼내면 자연스럽게 뒤집힌다"는 감각이 중요하네요.
 */

